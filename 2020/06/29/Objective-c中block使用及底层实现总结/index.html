<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Block作为iOS项目中的一种传值方式，经常在面试中被问到与代理的区别，还有就是Block的循环应用问题等都是iOS面试中老生常谈的问题，深一点的会问到Block的底层实现原理基底层数据结构。今天就总结写iOS中关于Block的一些常见知识点。 1.Block的定义关于Block定义简单来说Block就是闭包在Objective-C中实现，那什么是闭包呢？  In programming lan">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-c中block使用及底层实现总结">
<meta property="og:url" content="http://yoursite.com/2020/06/29/Objective-c%E4%B8%ADblock%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="一点轩">
<meta property="og:description" content="Block作为iOS项目中的一种传值方式，经常在面试中被问到与代理的区别，还有就是Block的循环应用问题等都是iOS面试中老生常谈的问题，深一点的会问到Block的底层实现原理基底层数据结构。今天就总结写iOS中关于Block的一些常见知识点。 1.Block的定义关于Block定义简单来说Block就是闭包在Objective-C中实现，那什么是闭包呢？  In programming lan">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/06/29/Objective-c%E4%B8%ADblock%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/block_layout.png">
<meta property="og:image" content="http://yoursite.com/2020/06/29/Objective-c%E4%B8%ADblock%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/1.png">
<meta property="article:published_time" content="2020-06-29T12:46:17.000Z">
<meta property="article:modified_time" content="2020-07-02T13:18:50.679Z">
<meta property="article:author" content="一颗韭菜">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/06/29/Objective-c%E4%B8%ADblock%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/block_layout.png">

<link rel="canonical" href="http://yoursite.com/2020/06/29/Objective-c%E4%B8%ADblock%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Objective-c中block使用及底层实现总结 | 一点轩</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">一点轩</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">苟日新，又日新，日日新</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/29/Objective-c%E4%B8%ADblock%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="一颗韭菜">
      <meta itemprop="description" content="登高自卑，行远自迩">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一点轩">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Objective-c中block使用及底层实现总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-29 20:46:17" itemprop="dateCreated datePublished" datetime="2020-06-29T20:46:17+08:00">2020-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-02 21:18:50" itemprop="dateModified" datetime="2020-07-02T21:18:50+08:00">2020-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">iOS 底层源码</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>Block</code>作为<code>iOS</code>项目中的一种传值方式，经常在面试中被问到与代理的区别，还有就是<code>Block</code>的循环应用问题等都是<code>iOS</code>面试中老生常谈的问题，深一点的会问到<code>Block</code>的底层实现原理基底层数据结构。今天就总结写<code>iOS</code>中关于<code>Block</code>的一些常见知识点。</p>
<h1 id="1-Block的定义"><a href="#1-Block的定义" class="headerlink" title="1.Block的定义"></a>1.<code>Block</code>的定义</h1><p>关于<code>Block</code>定义简单来说<code>Block</code>就是闭包在<code>Objective-C</code>中实现，那什么是闭包呢？</p>
<blockquote>
<p>In programming languages, a closure is a function or reference to a function together with a referencing environment—a table storing a reference to each of the non-local variables (also called free variables or upvalues) of that function.</p>
</blockquote>
<p>翻译过来的表达就是：</p>
<blockquote>
<p>闭包是一个函数（或指向函数的指针），再加上该函数执行的外部的上下文变量(有时候也称作自由变量）。</p>
</blockquote>
<a id="more"></a>
<p>可以简单的说<code>Block</code>就是可以捕获局部变量的匿名函数。就相当于<code>C</code>语言中的函数指针<br><code>C</code>语言中定义函数指针如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d"</span>,a, b);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 定义函数指针</span></span><br><span class="line"><span class="keyword">void</span>(*funtptr)(<span class="keyword">int</span>,<span class="keyword">int</span>) = &amp;func;</span><br><span class="line"><span class="comment">// 通过函数指针调用时</span></span><br><span class="line">(*funtptr)(<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p><code>Block</code>的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义格式： return_type (^blockName)(参数列表)</span></span><br><span class="line"><span class="comment">// 有参数没有返回值的block</span></span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">int</span> a, <span class="keyword">int</span> b) = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"a = %d, b = %d"</span>, a, b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">block(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">// 有返回值没参数的block</span></span><br><span class="line"><span class="keyword">int</span> (retBlcok)(<span class="keyword">void</span>) = ^ &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> result = retBlock();</span><br><span class="line"><span class="comment">// 有参数有返回值的block</span></span><br><span class="line"><span class="keyword">int</span> (retArgBlcok)(<span class="keyword">int</span> a, <span class="keyword">int</span> b)= ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = retArgBlock(<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>关于<code>Block</code>苹果官方是这样介绍的：</p>
<blockquote>
<p>Block objects are a C-level syntactic and runtime feature. They are similar to standard C functions, but in addition to executable code they may also contain variable bindings to automatic (stack) or managed (heap) memory</p>
</blockquote>
<p>翻译过来就是： <code>Block</code>对象是一种<code>C</code>语言层级的语法，使用运行时特性，与<code>C</code>语言的函数相似，除了可以执行代码外还能够捕获栈上的自动变量，或者管理堆上的内存。也就是说<code>Block</code>可以捕获局部变量，并管理的堆上的内存。</p>
<p>由苹果官方介绍可以看出在底层<code>Block</code>是对象。<br>通过命令：<code>clang -rewrite-objc 文件名</code>重写成<code>C++</code>代码来查看</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">        <span class="comment">// block能捕获局部变量的匿名函数</span></span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将以上代码重写后会在对应文件夹下生成<code>文件名.cpp</code>文件，打开该文件可以看到如下定义（省略部分无关代码）:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// block定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_8c_6kqk8fkx7b1084ct1sgc6lkw0000gn_T_main_b1b9ec_mi_1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_8c_6kqk8fkx7b1084ct1sgc6lkw0000gn_T_main_b1b9ec_mi_0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上变得代码中可以看出<code>__main_block_impl_0</code>是<code>Block</code>的定义，结构体重包含了<code>__block_impl</code>结构体以及结构体的描述结构体<code>__main_block_desc_0</code><br>其中<code>__block_impl</code>的定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>__main_block_impl_0</code>的构造函数中可以看出真正包含<code>Block</code>信息的是<code>__block_impl</code>结构体，而<code>__main_block_impl_0</code>不过是对<code>__block_impl</code>的又一层封装。从<code>__block_impl</code>的结构体成员中可以看出其含有<code>isa</code>指针，这也证明<code>Block</code>底层是类实现的事实。那么<code>isa</code>指向什么呢？我们可以打印下<code>block</code>的<code>superClass</code>输出：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"block"</span>);</span><br><span class="line">       &#125;;</span><br><span class="line">       block();</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"block Class is %@"</span>,[block <span class="keyword">class</span>]);</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"block superClass is %@"</span>,[[block <span class="keyword">class</span>] superclass]);</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"block superClass two is %@"</span>,[[[block <span class="keyword">class</span>] superclass] superclass]);</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"block superClass three is %@"</span>,[[[[block <span class="keyword">class</span>] superclass] superclass] superclass]);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-29</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">30.876138</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">35430</span>:<span class="number">1019454</span>] Hello, World!</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-29</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">30.876498</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">35430</span>:<span class="number">1019454</span>] block</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-29</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">30.876540</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">35430</span>:<span class="number">1019454</span>] block Class <span class="keyword">is</span> __NSGlobalBlock__</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-29</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">30.876568</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">35430</span>:<span class="number">1019454</span>] block superClass <span class="keyword">is</span> __NSGlobalBlock</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-29</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">30.876592</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">35430</span>:<span class="number">1019454</span>] block superClass two <span class="keyword">is</span> NSBlock</span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-29</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">30.876616</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">35430</span>:<span class="number">1019454</span>] block superClass three <span class="keyword">is</span> NSObject</span><br></pre></td></tr></table></figure>

<p>由以上输出可以看出<code>block</code>的继承链是<code>__NSGlobalBlock-&gt;__NSGlobalBlock-&gt;NSBlock-&gt;NSObject</code></p>
<h1 id="2-block变量的捕获"><a href="#2-block变量的捕获" class="headerlink" title="2.block变量的捕获"></a>2.block变量的捕获</h1><p>既然<code>Block</code>可以捕获变量，那么他的捕获机制是什么？ 我们都知道<code>Block</code>内部是不能修改其捕获的<strong>局部自动</strong>变量的，这是什么原因呢？<code>Block</code>所有的捕获变量都不能在其内部进行修改么？对于这个问题我们可以通过底层源码可以一探究竟。</p>
<h2 id="2-1-block捕获自动变量"><a href="#2-1-block捕获自动变量" class="headerlink" title="2.1 block捕获自动变量"></a>2.1 block捕获自动变量</h2><p>定义以下block代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^ &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"capture auto variable a = %d"</span>, a);</span><br><span class="line">&#125;;</span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>
<p>通过命令：<code>clang -rewrite-objc 文件名</code>将<code>Objective-C</code>代码重写成<code>C++</code>代码进行查看</p>
<p>那么<code>Block</code>底层到底是一种什么样的数据结构实现的呢，我们可以将含有<code>Block</code>的<code>Objective-C</code>代码通过命令：<code>clang -rewrite-objc 文件名</code>重写成<code>C++</code>代码来查看</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> _a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由以上代码可以看出，捕获局部变量的<code>block</code>在定义时会将捕获的变量以值得形式传入<code>block</code>内部。所以在<code>Block</code>外部改变局部变量的值并不会影响<code>Block</code>内部捕获的变量的值，调用block后输出的值仍然是5。</p>
<h2 id="2-2-block内包含全局变量"><a href="#2-2-block内包含全局变量" class="headerlink" title="2.2 block内包含全局变量"></a>2.2 block内包含全局变量</h2><p>对于全局变量<code>Block</code>内引入是怎样的一种机制呢，看代码最直观。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> globalVar = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">        <span class="comment">// block能捕获局部变量的匿名函数</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^ &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"capture auto variable a = %d"</span>, a);</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line">        <span class="keyword">void</span>(^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"capture global variable globalVar = %d"</span>, globalVar);</span><br><span class="line">        &#125;;</span><br><span class="line">        block1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写成c++代码后如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_1 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_1* Desc;</span><br><span class="line">  __main_block_impl_1(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_1 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_1(<span class="keyword">struct</span> __main_block_impl_1 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_8c_6kqk8fkx7b1084ct1sgc6lkw0000gn_T_main_a160aa_mi_2, globalVar);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_1 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_1_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_1)&#125;;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(*block1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_1((<span class="keyword">void</span> *)__main_block_func_1, &amp;__main_block_desc_1_DATA));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br></pre></td></tr></table></figure>
<p>可以看到<code>__main_block_impl_1</code>结构体重并没有捕获<code>globalVar</code>变量，在block1调用的时候直接去获取的<code>globalVar</code>变量，这是因为全局变量对于程序的所有代码都是可见的且其生命周期是整个程序的生命周期。所以block1不用捕获就可以直接访问。同理对于全局静态变量应该也是可以直接访问而不用捕获的。是否真的如此，我们可以通过代码验证。</p>
<h2 id="2-3-block内引用静态变量"><a href="#2-3-block内引用静态变量" class="headerlink" title="2.3 block内引用静态变量"></a>2.3 block内引用静态变量</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">        <span class="keyword">void</span>(^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"capture global static variable  = %d"</span>, b);</span><br><span class="line">        &#125;;</span><br><span class="line">        block1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写后：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_8c_6kqk8fkx7b1084ct1sgc6lkw0000gn_T_main_231843_mi_1, b);</span><br><span class="line">        &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>从上变得代码可以看到 同样的对于全局静态变量 block并不会去捕获，原因同上，应为全局的静态变量内存对于所有代码都是共享的。那么局部静态变量呢？ 我们在上边代码中添加一个局部静态变量试试看</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> *c;<span class="comment">// 以指针的形式形式出入</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> *_c, <span class="keyword">int</span> flags=<span class="number">0</span>) : c(_c) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从<code>__main_block_impl_0</code>的构成可以看出 对于局部静态变量 block会以指针的形式传入block内部。这是因为局部静态变量的生命周期也是整个程序，但是局部静态变量只能在声明它的函数内可访问，而block一般是为了延迟访问，有可能block的调用实在局部静态变量不可访问的域所以block会以指针的形式将静态变量捕获，以便于延迟调用。而局部auto变量会随着调用栈的销毁而销毁，block延迟调用时可能变量已经销毁，所以捕获的是其值，就算变量销毁了，block内部还是会持有变量临时值得拷贝。这也解释了为什么在block内部无法改变auto变量的值，而对于全局变量（包含全局静态变量）和局部静态变量在block内部是可以更改的事实。</p>
<h2 id="2-4-block内部引用Objective-C对象"><a href="#2-4-block内部引用Objective-C对象" class="headerlink" title="2.4 block内部引用Objective-C对象"></a>2.4 block内部引用Objective-C对象</h2><p>对于<code>Objective-C</code>对象由于对象本身是引用类型，其真正存储的地方在堆上，而其内存的释放是根据对象的引用计数来决定的，当引用增加时引用计数随之增加，引用减少时，引用计数随之减少，当引用计数为零时会回收掉相应的内存。block中会捕获对象的引用造成对象引用计数加一，由于是引用，所以在block内部对对象的改变会反映到外部对象上。同时如果该block又被其引用的对象强引用时，就会造成强引用环，从而使对象和block都不能得到释放，而造成内存泄露，这也是使用block要注意的，当然如果block是一个局部block并不会造成强引用环。</p>
<p>从以上四点可以对block捕获变量总结如下：</p>
<ul>
<li><ol>
<li>对于全局变量 block内部不会捕获，在block内部可以直接访问和改变全局变量的值。</li>
</ol>
</li>
<li><ol start="2">
<li>对于局部静态变量和<code>Objective-C</code>对象，block捕获的是引用，在block内部可以直接改变相关变量的值。</li>
</ol>
</li>
<li><ol start="3">
<li>对于局部auto变量 block捕获的是局部变量的临时值，在block内部不能更改局部变量的值。<br>对于第3条经常在面试中问到，如果想在block内部改变变量的值有哪几种方式？<br>无非以下三种</li>
</ol>
</li>
<li><ol>
<li>变量声明成局部静态变量，这回造成变量的内存释放不了而一直存在</li>
</ol>
</li>
<li><ol start="2">
<li>变量声明成全局变量，弊端同上</li>
</ol>
</li>
<li><ol start="3">
<li>将变量声明成<code>__block</code>类型的变量，为什么<code>__block</code>标记后 block内部就可以改变变量的值了呢，接下来我们就看一下底层对<code>__block</code>标记的变量做了什么。</li>
</ol>
</li>
</ul>
<h1 id="3-block的实现机制"><a href="#3-block的实现机制" class="headerlink" title="3. __block的实现机制"></a>3. __block的实现机制</h1><p>对于<code>__block</code>标记的变量，在block内部可以更改变量的值，我们都知道这种用法，但是他的实现机制是什么呢？为什么标记后在block内部就可以改变原来不能改变的变量的值了呢？通过代码我们可以看到<code>__block</code>的底层实现机制，先实现如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> a = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">void</span>(^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    a = <span class="number">11</span>;</span><br><span class="line">&#125;;</span><br><span class="line">a += <span class="number">12</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Before block a = %d"</span>, a);</span><br><span class="line">block1();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"After block a = %d"</span>, a);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"block is %@"</span>,block1);</span><br></pre></td></tr></table></figure>
<p>执行后可以看到如下输出:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-30</span> <span class="number">22</span>:<span class="number">16</span>:<span class="number">35.639996</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">50394</span>:<span class="number">1414829</span>] Before block a = <span class="number">25</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-30</span> <span class="number">22</span>:<span class="number">16</span>:<span class="number">35.640425</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">50394</span>:<span class="number">1414829</span>] After block a = <span class="number">11</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-30</span> <span class="number">22</span>:<span class="number">16</span>:<span class="number">35.640626</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">50394</span>:<span class="number">1414829</span>] block is &lt;__NSMallocBlock__: <span class="number">0x10061c220</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到a的值已经被block更改了<br>通过<code>clang -rewrite-objc 文件名</code>命令将代码重写成<code>C++</code>代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装__block标记变量的结构体</span></span><br><span class="line"><span class="keyword">struct</span> __Block_byref_a_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_a_0 *a; <span class="comment">// 捕获变量a时通过__Block_byref_a_0结构体指针</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">            (a-&gt;__forwarding-&gt;a) = <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;a, (<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_a_0 a = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_a_0), <span class="number">13</span>&#125;;</span><br><span class="line">        <span class="keyword">void</span>(*block1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="number">570425344</span>));</span><br><span class="line">        (a.__forwarding-&gt;a) += <span class="number">12</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_8c_6kqk8fkx7b1084ct1sgc6lkw0000gn_T_main_e7b244_mi_0, (a.__forwarding-&gt;a));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block1)-&gt;FuncPtr)((__block_impl *)block1);</span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_8c_6kqk8fkx7b1084ct1sgc6lkw0000gn_T_main_e7b244_mi_1, (a.__forwarding-&gt;a));</span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_8c_6kqk8fkx7b1084ct1sgc6lkw0000gn_T_main_e7b244_mi_2,block1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比于原来的代码现在多了一个名为<code>__Block_byref_a_0</code>的结构体，从结构体的名字可以看出大概意思就是block通过ref(引用)引用a，从代码可以看出<code>__block</code>标记变量后，会把变量包装成<code>__Block_byref_a_0</code>。<br>可以看到<code>__Block_byref_a_0</code>结构体包含<code>__isa</code>指针、一个指向自身结构的<code>__forwarding</code>指针还有标记变量的同类型同名字的变量<code>a</code>。<code>__main_block_impl_0</code>构造时传入的是<code>_a-&gt;__forwarding</code>指针，注意这个时候<code>_a</code>是栈上<code>__Block_byref_a_0</code>类型的结构体。而<code>__main_block_impl_0</code>内部捕获的<code>a</code>是栈上<code>_a</code>的拷贝，<code>a</code>是在堆上而<code>_a</code>实在栈上的，<code>_a-&gt;__forwarding</code>指针指向的是<code>a</code>。而堆上<code>a</code>的<code>__forwarding</code>指针指向的是其自身，这样在<code>__main_block_func_0</code>方法中调用<code>(a-&gt;__forwarding-&gt;a) = 11</code>时在栈上的<code>_a</code>也能看到变量的变化。</p>
<p>总结一下就是<code>__block</code>标记变量后，会把变量封装进<code>__Block_byref_var_0</code>类型的结构体中，block捕获结构体变量时会将<code>__Block_byref_var_0</code>变量在复制到堆上，同时将栈上的结构体的<code>__forwarding</code>指针指向堆上的结构体，而堆上结构的<code>__forwarding</code>指针指向堆上的结构体自身。在block内部操作的是堆上的结构体。对变量的操作会通过栈上结构体的 <code>__forwarding</code>指针反映出来。<br>既然<code>Block</code>类型底层也是通过类实现的那么底层真正的数据结构优势怎么样的呢，这可以通过查看苹果官方源码得到，关于<code>Block</code>的底层实现的源码可以在<a href="https://opensource.apple.com/source/libclosure/libclosure-74/" target="_blank" rel="noopener">这里</a>查看，<br>如果想下载苹果的源码可以找到对应源码的实现，就比如：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Block源码的地址是： http<span class="variable">s:</span>//opensource.apple.<span class="keyword">com</span>/<span class="keyword">source</span>/libclosure/libclosure-<span class="number">74</span>/</span><br><span class="line">要想下载源码只需要将<span class="keyword">source</span>改为tarballs 链接后边添加.tar.gz就可以了：</span><br><span class="line">http<span class="variable">s:</span>//opensource.apple.<span class="keyword">com</span>/tarballs/libclosure/libclosure-<span class="number">74</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>学到这里一定会觉得对<code>Block</code>了解的差不多了，那么让我们来看看下边这段代码输出会是什么：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)<span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">        </span><br><span class="line">        Person *p = [[Person alloc]init];</span><br><span class="line">        p.name = <span class="string">@"Jhon"</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Before block person's retain count is %ld"</span>,<span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)p));</span><br><span class="line">        <span class="keyword">void</span>(^block1)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block contains person %@"</span>, p.name);</span><br><span class="line">            p.name = <span class="string">@"Block"</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"in block person's retain count is %ld"</span>,<span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)p));</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"person's retain count is %ld"</span>,<span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)p));</span><br><span class="line">        block1();</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"out block name is %@"</span>,p.name);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block is %@"</span>,block1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯… block 会捕获p从而增加p的引用计数，所以输出是 1、2、2对不对？ 跑一下程序：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">19</span>:<span class="number">23</span>:<span class="number">40.834241</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">70858</span>:<span class="number">2088444</span>] Before block person<span class="string">'s retain count is 1</span></span><br><span class="line"><span class="string">2020-07-02 19:23:40.834286+0800 BlockLearnDemo[70858:2088444] person'</span>s <span class="keyword">retain</span> count is <span class="number">3</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">19</span>:<span class="number">23</span>:<span class="number">40.834390</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">70858</span>:<span class="number">2088444</span>] block contains person Jhon</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">19</span>:<span class="number">23</span>:<span class="number">40.834441</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">70858</span>:<span class="number">2088444</span>] <span class="keyword">in</span> block person<span class="string">'s retain count is 3</span></span><br><span class="line"><span class="string">2020-07-02 19:23:40.834493+0800 BlockLearnDemo[70858:2088444] out block name is Block</span></span><br><span class="line"><span class="string">2020-07-02 19:23:40.834690+0800 BlockLearnDemo[70858:2088444] block is &lt;__NSMallocBlock__: 0x100604360&gt;</span></span><br></pre></td></tr></table></figure>
<p>嗯？ 输出竟然是1、3、3 会什么是3呢？刚开始我也是懵逼的，后来才发现问题的所在，在解释之前，我们先将代变一下，让代码输出1、2、2只需要将block1的赋值语句变为如下代码，不用block1：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block contains person %@"</span>, p.name);</span><br><span class="line">            p.name = <span class="string">@"Block"</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"in block person's retain count is %ld"</span>,<span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)p));</span><br><span class="line">        &#125;();</span><br></pre></td></tr></table></figure>
<p>运行一下，我看到控制台的输出</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">19</span>:<span class="number">32</span>:<span class="number">17.775182</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">71409</span>:<span class="number">2094332</span>] Before block person<span class="string">'s retain count is 1</span></span><br><span class="line"><span class="string">2020-07-02 19:32:17.775293+0800 BlockLearnDemo[71409:2094332] block contains person Jhon</span></span><br><span class="line"><span class="string">2020-07-02 19:32:17.775370+0800 BlockLearnDemo[71409:2094332] in block person'</span>s <span class="keyword">retain</span> count is <span class="number">2</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">19</span>:<span class="number">32</span>:<span class="number">17.775406</span>+<span class="number">0800</span> BlockLearnDemo[<span class="number">71409</span>:<span class="number">2094332</span>] person<span class="string">'s retain count is 2</span></span><br></pre></td></tr></table></figure>
<p>为什么将block赋值给block1的时候p的引用计数增加了呢？ 这是因为，不赋值的时候block是在栈上，此时block增加p的引用计数为2，当将block赋值给block1时会将block拷贝到堆上，同时增加p的引用计数为3。就是在赋值的过程中发生了拷贝，同时也拷贝了block捕获的对象。这就涉及到了block底层源码实现，那就让我们来看看<code>Block</code>底层到底是如何实现的。</p>
<h1 id="4-block的源码分析"><a href="#4-block的源码分析" class="headerlink" title="4. block的源码分析"></a>4. block的源码分析</h1><h2 id="4-1-block的数据结构"><a href="#4-1-block的数据结构" class="headerlink" title="4.1 block的数据结构"></a>4.1 block的数据结构</h2><p>在<code>Block_private.h</code>中我们可以找到</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">volatile</span> int32_t flags; <span class="comment">// contains ref count</span></span><br><span class="line">    int32_t reserved;</span><br><span class="line">    BlockInvokeFunction invoke;</span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor_1 *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>Block_layout</code>结构体就是<code>Block</code>的底层的树结构,可以看出这个结构体和<code>__block_impl</code>是一样的。包含了一下内容：</p>
<ul>
<li><code>isa</code>指针 指向block所属的类。</li>
<li><code>flag</code>包含block的引用计数，使用flag的二进制的一些bit位来存储。</li>
<li><code>reserved</code> 保留数据，用于以后扩展。</li>
<li><code>invoke</code>block的回调方法。</li>
<li><code>descriptor</code>block的描述，包含block的大小和将来扩展的保留数据参数，总共有三种<code>descriptor</code>后边介绍。</li>
<li>imported variables: 捕获的变量如果有的话。<br>结构如图：<img src="/2020/06/29/Objective-c%E4%B8%ADblock%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/block_layout.png" class="">
<h3 id="4-1-1-block的类"><a href="#4-1-1-block的类" class="headerlink" title="4.1.1 block的类"></a>4.1.1 block的类</h3>根据block是否捕获变量以及捕获变量类型的不同，block可以分为三种<ul>
<li><strong>NSGlobalBlock</strong> ：不捕获任何变量的block</li>
<li><strong>NSStackBlock</strong>: 捕获基本类型变量的block</li>
<li><strong>NSMallocBlock</strong>: 捕获objectiv-C对象的block</li>
</ul>
</li>
</ul>
<p>在ARC条件下一般只会有<code>NSGlobalBlock</code>和<code>NSMallocBlock</code>两种，这是因为ARC条件下编译器会自动将NSStackBlock拷贝到堆区。</p>
<h3 id="4-1-2-block的引用计数"><a href="#4-1-2-block的引用计数" class="headerlink" title="4.1.2 block的引用计数"></a>4.1.2 block的引用计数</h3><p><code>Block_layot</code>结构体中<code>flag</code>字段包含block的引用计数，<code>flag</code>的一些bit位由如下枚举组成：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values for Block_layout-&gt;flags to describe block objects</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BLOCK_DEALLOCATING =      (<span class="number">0x0001</span>),  <span class="comment">// runtime 低16位的最低位标记block是否正在销毁</span></span><br><span class="line">    BLOCK_REFCOUNT_MASK =     (<span class="number">0xfffe</span>),  <span class="comment">// runtime 低15位的后15位用于存储block的引用计数。</span></span><br><span class="line">    BLOCK_NEEDS_FREE =        (<span class="number">1</span> &lt;&lt; <span class="number">24</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_HAS_COPY_DISPOSE =  (<span class="number">1</span> &lt;&lt; <span class="number">25</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_CTOR =          (<span class="number">1</span> &lt;&lt; <span class="number">26</span>), <span class="comment">// compiler: helpers have C++ code</span></span><br><span class="line">    BLOCK_IS_GC =             (<span class="number">1</span> &lt;&lt; <span class="number">27</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_IS_GLOBAL =         (<span class="number">1</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_USE_STRET =         (<span class="number">1</span> &lt;&lt; <span class="number">29</span>), <span class="comment">// compiler: undefined if !BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    BLOCK_HAS_SIGNATURE  =    (<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_EXTENDED_LAYOUT=(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)  <span class="comment">// compiler</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>BLOCK_REFCOUNT_MAST</code>用来存储block的引用计数，最多可以存3万多。。。<br><code>BLOCK_NEEDS_FREE</code>block需不需要释放，可以当做block是否在堆上，当栈上block发生拷贝时该标志位会变为1.<code>BLOCK_HAS_SIGNATURE</code>block的方法签名。</p>
<h3 id="4-1-3-block的三种描述"><a href="#4-1-3-block的三种描述" class="headerlink" title="4.1.3 block的三种描述"></a>4.1.3 block的三种描述</h3><p>block有三种<code>descriptor</code>分表包含了block的大小、block的拷贝和释放方法、block的方法签名和额外布局，三种<code>descriptor</code>结构如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_DESCRIPTOR_1 1</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor_1 &#123;</span><br><span class="line">    uintptr_t reserved;</span><br><span class="line">    uintptr_t size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_DESCRIPTOR_2 1</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor_2 &#123;</span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_COPY_DISPOSE</span></span><br><span class="line">    BlockCopyFunction <span class="keyword">copy</span>;</span><br><span class="line">    BlockDisposeFunction dispose;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_DESCRIPTOR_3 1</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor_3 &#123;</span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *signature;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *layout;     <span class="comment">// contents depend on BLOCK_HAS_EXTENDED_LAYOUT</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-对-block变量的包装结构"><a href="#4-2-对-block变量的包装结构" class="headerlink" title="4.2 对__block变量的包装结构"></a>4.2 对__block变量的包装结构</h2><p><strong>block标记后的变量之所以能在block内部更改，是因为底层用了以下的数据结构，将</strong>block标记的变量做了二次封装。<br>包装后在block内的引用如下图</p>
<img src="/2020/06/29/Objective-c%E4%B8%ADblock%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93/1.png" class="">

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values for Block_byref-&gt;flags to describe __block variables</span></span><br><span class="line"><span class="comment">// Block_byref_flags 的枚举值用来描述__block 标记的变量</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">// Byref refcount must use the same bits as Block_layout's refcount.</span></span><br><span class="line">    <span class="comment">// BLOCK_DEALLOCATING =      (0x0001),  // runtime</span></span><br><span class="line">    <span class="comment">// BLOCK_REFCOUNT_MASK =     (0xfffe),  // runtime</span></span><br><span class="line"></span><br><span class="line">    BLOCK_BYREF_LAYOUT_MASK =       (<span class="number">0xf</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_BYREF_LAYOUT_EXTENDED =   (  <span class="number">1</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_BYREF_LAYOUT_NON_OBJECT = (  <span class="number">2</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler __block 标记的变量非对象</span></span><br><span class="line">    BLOCK_BYREF_LAYOUT_STRONG =     (  <span class="number">3</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler __block 标记的变量是对象</span></span><br><span class="line">    BLOCK_BYREF_LAYOUT_WEAK =       (  <span class="number">4</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler __block 标记的变量是弱引用对象</span></span><br><span class="line">    BLOCK_BYREF_LAYOUT_UNRETAINED = (  <span class="number">5</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line"></span><br><span class="line">    BLOCK_BYREF_IS_GC =             (  <span class="number">1</span> &lt;&lt; <span class="number">27</span>), <span class="comment">// runtime</span></span><br><span class="line"></span><br><span class="line">    BLOCK_BYREF_HAS_COPY_DISPOSE =  (  <span class="number">1</span> &lt;&lt; <span class="number">25</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_BYREF_NEEDS_FREE =        (  <span class="number">1</span> &lt;&lt; <span class="number">24</span>), <span class="comment">// runtime</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Block_byref &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">struct</span> Block_byref *forwarding;</span><br><span class="line">    <span class="keyword">volatile</span> int32_t flags; <span class="comment">// contains ref count</span></span><br><span class="line">    uint32_t size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//当__block标记的变量时Objective-C对象时会有对象的拷贝和销毁函数</span></span><br><span class="line"><span class="comment">//用于增加或者减少引用对象的引用计数</span></span><br><span class="line"><span class="keyword">struct</span> Block_byref_2 &#123;</span><br><span class="line">    <span class="comment">// requires BLOCK_BYREF_HAS_COPY_DISPOSE</span></span><br><span class="line">    BlockByrefKeepFunction byref_keep;</span><br><span class="line">    BlockByrefDestroyFunction byref_destroy;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// __block标记的变量包装后的布局。</span></span><br><span class="line"><span class="keyword">struct</span> Block_byref_3 &#123;</span><br><span class="line">    <span class="comment">// requires BLOCK_BYREF_LAYOUT_EXTENDED</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *layout;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="5-block和-block标记变量的拷贝机制"><a href="#5-block和-block标记变量的拷贝机制" class="headerlink" title="5. block和__block标记变量的拷贝机制"></a>5. block和__block标记变量的拷贝机制</h1><p>代码中声明的block应该是在栈上的代码区的，在ARC条件下编译器会将栈上的block拷贝到堆上，这个过程会调用<code>_Block_copy</code>函数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.</span></span><br><span class="line"><span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="keyword">struct</span> Block_layout *aBlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following would be better done as a switch statement</span></span><br><span class="line">    aBlock = (<span class="keyword">struct</span> Block_layout *)arg;</span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        <span class="comment">// BLOCK_NEEDS_FREE表示block已经在堆上了，这时并不是真的拷贝，只是增加block的引用计数</span></span><br><span class="line">        <span class="comment">// latches on high</span></span><br><span class="line">        latching_incr_int(&amp;aBlock-&gt;flags);<span class="comment">// 增加block的引用计数</span></span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">        <span class="comment">// 全局block直接返回</span></span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Its a stack block.  Make a copy.</span></span><br><span class="line">        <span class="comment">// 栈block 进行拷贝</span></span><br><span class="line">        <span class="keyword">struct</span> Block_layout *result =</span><br><span class="line">            (<span class="keyword">struct</span> Block_layout *)malloc(aBlock-&gt;descriptor-&gt;size);</span><br><span class="line">        <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); <span class="comment">// bitcopy first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">        <span class="comment">// Resign the invoke pointer as it uses address authentication.</span></span><br><span class="line">        result-&gt;invoke = aBlock-&gt;invoke;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// reset refcount</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed</span></span><br><span class="line">        <span class="comment">// 低32位的最后一位用于标记block是否在销毁，从第2未开始是引用计数，所以引用计数加1</span></span><br><span class="line">        <span class="comment">// 实际上是要加2</span></span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br><span class="line">        _Block_call_copy_helper(result, aBlock);</span><br><span class="line">        <span class="comment">// Set isa last so memory analysis tools see a fully-initialized object.</span></span><br><span class="line">        <span class="comment">// 把isa指针换成_NSConcreteMallocBlock</span></span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__block 标记变量的拷贝代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runtime entry points for maintaining the sharing knowledge of byref data blocks.</span></span><br><span class="line"><span class="comment">// 运行时维护block共享的引用类型数据的入口</span></span><br><span class="line"><span class="comment">// A closure has been copied and its fixup routine is asking us to fix up the reference to the shared byref data</span></span><br><span class="line"><span class="comment">// 被拷贝的闭包及其修复历程要我们主动去修复共享引用数据的引用计数。</span></span><br><span class="line"><span class="comment">// 栈上的闭包虽然被拷贝到堆上，但是栈上的要依然可用，栈上的闭包可以通过变量的forwarding指针间接的</span></span><br><span class="line"><span class="comment">// 访问变量(此时访问的是堆上的变量)</span></span><br><span class="line"><span class="comment">// Closures that aren't copied must still work, so everyone always accesses variables after dereferencing the forwarding ptr.</span></span><br><span class="line"><span class="comment">// 如果bref指针已经被拷贝到堆上，就增加他的引用计数并返回。</span></span><br><span class="line"><span class="comment">// We ask if the byref pointer that we know about has already been copied to the heap, and if so, increment and return it.</span></span><br><span class="line"><span class="comment">// 如果bref指针没有拷贝到堆，就拷贝到堆上，并将栈上变量的forwarding指针指向堆上</span></span><br><span class="line"><span class="comment">// Otherwise we need to copy it and update the stack forwarding pointer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> Block_byref *_Block_byref_copy(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="keyword">struct</span> Block_byref *src = (<span class="keyword">struct</span> Block_byref *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// src points to stack</span></span><br><span class="line">        <span class="comment">// __block变量还在栈上需要拷贝到堆上</span></span><br><span class="line">        <span class="keyword">struct</span> Block_byref *<span class="keyword">copy</span> = (<span class="keyword">struct</span> Block_byref *)malloc(src-&gt;size);</span><br><span class="line">        <span class="keyword">copy</span>-&gt;isa = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// byref value 4 is logical refcount of 2: one for caller, one for stack</span></span><br><span class="line">        <span class="comment">// 引用计数是2因为__block标记后生成Block_byref时引用计数是1 拷贝到堆上时增加1，引用计数从</span></span><br><span class="line">        <span class="comment">// 第2位开始，所以物理上增加4才是实际是2个引用数</span></span><br><span class="line">        <span class="keyword">copy</span>-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">copy</span>-&gt;forwarding = <span class="keyword">copy</span>; <span class="comment">// patch heap copy to point to itself</span></span><br><span class="line">        src-&gt;forwarding = <span class="keyword">copy</span>;  <span class="comment">// patch stack to point to heap copy</span></span><br><span class="line">        <span class="keyword">copy</span>-&gt;size = src-&gt;size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            <span class="comment">// Trust copy helper to copy everything of interest</span></span><br><span class="line">            <span class="comment">// If more than one field shows up in a byref block this is wrong XXX</span></span><br><span class="line">            <span class="keyword">struct</span> Block_byref_2 *src2 = (<span class="keyword">struct</span> Block_byref_2 *)(src+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">struct</span> Block_byref_2 *copy2 = (<span class="keyword">struct</span> Block_byref_2 *)(<span class="keyword">copy</span>+<span class="number">1</span>);</span><br><span class="line">            copy2-&gt;byref_keep = src2-&gt;byref_keep;</span><br><span class="line">            copy2-&gt;byref_destroy = src2-&gt;byref_destroy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_BYREF_LAYOUT_EXTENDED) &#123;</span><br><span class="line">                <span class="keyword">struct</span> Block_byref_3 *src3 = (<span class="keyword">struct</span> Block_byref_3 *)(src2+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">struct</span> Block_byref_3 *copy3 = (<span class="keyword">struct</span> Block_byref_3*)(copy2+<span class="number">1</span>);</span><br><span class="line">                copy3-&gt;layout = src3-&gt;layout;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            (*src2-&gt;byref_keep)(<span class="keyword">copy</span>, src);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Bitwise copy.</span></span><br><span class="line">            <span class="comment">// This copy includes Block_byref_3, if any.</span></span><br><span class="line">            memmove(<span class="keyword">copy</span>+<span class="number">1</span>, src+<span class="number">1</span>, src-&gt;size - <span class="keyword">sizeof</span>(*src));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// already copied to heap</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) == BLOCK_BYREF_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> src-&gt;forwarding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>啊。。。就总结这么多吧，看源代码和总结还是有差距的，发现很多理解的表打不出来，以后看来要多看多写。另外block的使用还要注意循环引用的问题，对于循环引用的解决一般有以下三种:</p>
<ul>
<li><ol>
<li><strong>weak变量，再在block内部对</strong>weak做强引用</li>
</ol>
</li>
<li><ol start="2">
<li><strong>block变量，使用block内部引用到的变量类型生成一个临时的</strong>block变量，内部使用后将变量置为nil防止循环引用</li>
</ol>
</li>
<li><ol start="3">
<li><strong>unsafe_unretained 变量，很少用，相对于</strong>weak变量 __unsafe_unretained在对象销毁时，并不会将引用地址置为nil会造成悬垂指针。</li>
</ol>
</li>
</ul>
<p>第三篇就到此结束，写博客总结真是痛苦，这篇拖了一两周，还写得不明不白的。真是佩服那些能把知识点讲的很明白的大牛。继续努力。</p>
<h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://ityongzhen.github.io/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS%E7%9A%84block.html/" target="_blank" rel="noopener">深入理解iOS的block</a></p>
<p><a href="https://segmentfault.com/a/1190000018927685?utm_source=tag-newest" target="_blank" rel="noopener">探索iOS中Block的实现</a></p>
<p><a href="https://opensource.apple.com/source/libclosure/libclosure-74/" target="_blank" rel="noopener">libcolure-74</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"><i class="fa fa-tag"></i> iOS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/25/iOS%E4%B8%AD%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" rel="prev" title="iOS中定时器的使用总结">
      <i class="fa fa-chevron-left"></i> iOS中定时器的使用总结
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Block的定义"><span class="nav-number">1.</span> <span class="nav-text">1.Block的定义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-block变量的捕获"><span class="nav-number">2.</span> <span class="nav-text">2.block变量的捕获</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-block捕获自动变量"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 block捕获自动变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-block内包含全局变量"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 block内包含全局变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-block内引用静态变量"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 block内引用静态变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-block内部引用Objective-C对象"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 block内部引用Objective-C对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-block的实现机制"><span class="nav-number">3.</span> <span class="nav-text">3. __block的实现机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-block的源码分析"><span class="nav-number">4.</span> <span class="nav-text">4. block的源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-block的数据结构"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 block的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-block的类"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1 block的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-block的引用计数"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2 block的引用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-block的三种描述"><span class="nav-number">4.1.3.</span> <span class="nav-text">4.1.3 block的三种描述</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-对-block变量的包装结构"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 对__block变量的包装结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-block和-block标记变量的拷贝机制"><span class="nav-number">5.</span> <span class="nav-text">5. block和__block标记变量的拷贝机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料："><span class="nav-number">6.</span> <span class="nav-text">参考资料：</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="一颗韭菜"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">一颗韭菜</p>
  <div class="site-description" itemprop="description">登高自卑，行远自迩</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aTuberosum" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aTuberosum" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/930417452@qq.com" title="E-Mail → 930417452@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">一颗韭菜</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">31k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">28 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
